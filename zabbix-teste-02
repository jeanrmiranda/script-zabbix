#!/usr/bin/env python3
import os
import requests
import statistics
from datetime import datetime, timedelta, timezone
from calendar import monthrange

# =======================
# CONFIG
# =======================
ZABBIX_URL = "https://zabbix.toledofibra.net.br/api_jsonrpc.php"
AUTH_TOKEN = os.getenv("ZABBIX_TOKEN", "827be10800577e595a26a0cad5ccac7976d8b459f27adf593182fceb18a2ee69")
HOSTNAME = "router-edge-for"

ITEM_KEYS = [
    "net.if.in[ifHCInOctets.10]",
    "net.if.in[ifHCInOctets.11]",
    "net.if.in[ifHCInOctets.12]",
]

# Se True: usa últimos 30 dias; se False: mês anterior fechado
ULTIMOS_30_DIAS = False

# SSL do requests
VERIFY_SSL = False
HTTP_TIMEOUT = 60

# Impressões opcionais
PRINT_TOTAL = False          # mostra total (bytes) — desativado para não confundir
PRINT_P95 = True             # mostra 95º percentil (bits/s)

# =======================
# Tempo
# =======================
def intervalo_mes_anterior_utc(now_utc: datetime):
    ano = now_utc.year if now_utc.month > 1 else now_utc.year - 1
    mes = now_utc.month - 1 if now_utc.month > 1 else 12
    inicio = datetime(ano, mes, 1, 0, 0, 0, tzinfo=timezone.utc)
    fim = datetime(ano, mes, monthrange(ano, mes)[1], 23, 59, 59, tzinfo=timezone.utc)
    return int(inicio.timestamp()), int(fim.timestamp())

def intervalo_ultimos_30_dias_utc(now_utc: datetime):
    return int((now_utc - timedelta(days=30)).timestamp()), int(now_utc.timestamp())

# =======================
# API
# =======================
def zabbix_api(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "auth": AUTH_TOKEN, "id": 1}
    r = requests.post(ZABBIX_URL, json=payload, verify=VERIFY_SSL, timeout=HTTP_TIMEOUT)
    r.raise_for_status()
    j = r.json()
    if "error" in j:
        raise RuntimeError(j["error"])
    return j["result"]

# =======================
# Helpers
# =======================
def format_bps(bps: float) -> str:
    # escalas decimais para redes (K/M/G/T bps)
    units = ["bps", "Kbps", "Mbps", "Gbps", "Tbps"]
    v = float(bps)
    i = 0
    while v >= 1000 and i < len(units) - 1:
        v /= 1000.0
        i += 1
    return f"{v:.2f} {units[i]}"

def format_total_bytes(num_bytes: float) -> str:
    gb = num_bytes / (1024 ** 3)
    if gb >= 1024:
        return f"{gb/1024:.2f} TB"
    return f"{gb:.2f} GB"

def percentile(values, p):
    if not values:
        return None
    vals = sorted(values)
    k = (len(vals) - 1) * (p / 100.0)
    f = int(k)
    c = min(f + 1, len(vals) - 1)
    if f == c:
        return vals[f]
    return vals[f] + (vals[c] - vals[f]) * (k - f)

# =======================
# Main
# =======================
def main():
    if not VERIFY_SSL:
        try:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        except Exception:
            pass

    now = datetime.now(timezone.utc)
    if ULTIMOS_30_DIAS:
        time_from, time_till = intervalo_ultimos_30_dias_utc(now)
    else:
        time_from, time_till = intervalo_mes_anterior_utc(now)

    print(f"Período: {datetime.utcfromtimestamp(time_from)} UTC até {datetime.utcfromtimestamp(time_till)} UTC\n")

    # Resolver itemids
    items = zabbix_api("item.get", {
        "output": ["itemid", "name", "key_", "units"],
        "host": HOSTNAME,
        "filter": {"key_": ITEM_KEYS},
    })

    found = {it["key_"]: it for it in items}
    missing = [k for k in ITEM_KEYS if k not in found]
    if missing:
        print("Itens não encontrados no host:", missing)
        raise SystemExit(1)

    for key in ITEM_KEYS:
        it = found[key]
        itemid = it["itemid"]
        nome = it.get("name", key)

        trends = zabbix_api("trend.get", {
            "output": ["clock", "num", "value_avg", "value_min", "value_max"],
            "itemids": itemid,
            "time_from": time_from,
            "time_till": time_till,
            "sortfield": "clock",
            "sortorder": "ASC",
        })

        if not trends:
            print(f"[{key}] {nome}: sem dados no período.\n")
            continue

        # Considera apenas horas com amostras
        buckets = [t for t in trends if int(t.get("num", 0)) > 0]
        if not buckets:
            print(f"[{key}] {nome}: sem amostras válidas no período.\n")
            continue

        # Arrays de estatísticas
        avgs = [float(t["value_avg"]) for t in buckets]  # bits/s (média de cada hora)
        mins = [float(t["value_min"]) for t in buckets]
        maxs = [float(t["value_max"]) for t in buckets]

        # Média do período (bits/s) = total_bits / tempo_medido
        total_bits = sum(a * 3600 for a in avgs)           # soma de (média_hora * 3600s)
        horas_medidas = len(buckets)                       # número de horas com dados
        media_periodo_bps = total_bits / (horas_medidas * 3600.0)  # == statistics.mean(avgs)

        # Estatísticas adicionais
        minimo = min(mins)
        maximo = max(maxs)
        p95 = percentile(avgs, 95.0) if PRINT_P95 else None

        print(f"[{key}] {nome}")
        print(f"  Média no período: {format_bps(media_periodo_bps)}")
        print(f"  Mínimo horário:   {format_bps(minimo)} | Máximo horário: {format_bps(maximo)}")
        if p95 is not None:
            print(f"  95º percentil:    {format_bps(p95)}")
        if PRINT_TOTAL:
            total_bytes = total_bits / 8.0
            print(f"  Total (opcional): {format_total_bytes(total_bytes)}")
        print()

if __name__ == "__main__":
    try:
        main()
    except requests.exceptions.RequestException as e:
        print(f"Erro HTTP/Conexão: {e}")
    except RuntimeError as e:
        print(f"Erro na API do Zabbix: {e}")
    except Exception as e:
        print(f"Falha inesperada: {e}")
